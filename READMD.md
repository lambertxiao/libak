# 简介

## 为什写libak

### 其一

为了解决一种业务场景，假设我们有一条消息希望发送给服务端

```c++
struct HelloMsg {
  std::string field1;
  uint32_t field2;
  char* field3;
  char* field3_len;
};
```

在一开始的时候，为了方便，使用了json进行数据传输，所以我们实际发出去的消息长这样

```json
{
  "field1": "foo",
  "field2": 10,
  "field3": "xxxxxxxxxxx"
}
```

很久以后，线上的数据发现用json传输效率比较低，因此决定将数据格式改为protobuf, 这个时候我们实际发出去的消息长这样

```
field1:foo,field2:10,field3:xxxxxxxxxxx
```

再后来，由于业务变动，HelloMsg里面加了大量的字段，并且主要用来传输二进制数据，这个时候用protobuf会有额外的开销，所以我们决定直接使用二进制传输数据，规定每个字段的数据占用字节，最后实际发出去的消息可能长这个样子

```
sdsdsadauhdsgisdpfgqu348236571874uikfjdsfjsdyu[f'fp]]
```

总结，对上都是同一条msg格式，但是呢，实际传输的时候，它可以是json格式，pb格式，二进制格式；当然发出去是json，收到的包也一定是json，所以具体用什么格式来发送交由上层根据业务场景来决定，将消息内容和消息序列化给解耦开

### 其二

为了可以灵活地使用某种传输层协议，如tcp，udp，quic

由于tcp性能不高，某天服务端升级了，支持使用quic协议传输数据了，client端可以简单地通过配置项，修改底层的数据传输协议，由libak来处理不同的传输层协议的链接建立以及传输。

### 其三

不同于一般的网络库，消息的序列化及反序列化对上都是屏蔽的，libak将该过程交由上层实现，使得上层能利用内存池，对象池等技术进行更加高效的编包拆包。
